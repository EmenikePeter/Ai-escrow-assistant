diff --git a/node_modules/@stripe/stripe-react-native/android/src/main/java/com/reactnativestripesdk/pushprovisioning/PushProvisioningProxy.kt b/node_modules/@stripe/stripe-react-native/android/src/main/java/com/reactnativestripesdk/pushprovisioning/PushProvisioningProxy.kt
index 9f16513..c082224 100644
--- a/node_modules/@stripe/stripe-react-native/android/src/main/java/com/reactnativestripesdk/pushprovisioning/PushProvisioningProxy.kt
+++ b/node_modules/@stripe/stripe-react-native/android/src/main/java/com/reactnativestripesdk/pushprovisioning/PushProvisioningProxy.kt
@@ -1,7 +1,6 @@
 package com.reactnativestripesdk.pushprovisioning
 
 import android.app.Activity
-import android.app.Activity.RESULT_OK
 import android.content.Intent
 import android.content.pm.PackageManager
 import android.nfc.NfcAdapter
@@ -11,22 +10,22 @@ import com.facebook.react.bridge.ReactApplicationContext
 import com.facebook.react.bridge.ReadableMap
 import com.reactnativestripesdk.utils.createError
 import com.reactnativestripesdk.utils.mapError
-import com.stripe.android.pushProvisioning.PushProvisioningActivity
-import com.stripe.android.pushProvisioning.PushProvisioningActivityStarter
+
+private const val TAG = "StripePushProvisioning"
+private const val STARTER_CLASS = "com.stripe.android.pushProvisioning.PushProvisioningActivityStarter"
+private const val ARGS_CLASS = "$STARTER_CLASS\$Args"
+private const val ERROR_CLASS = "$STARTER_CLASS\$Error"
+private const val ACTIVITY_CLASS = "com.stripe.android.pushProvisioning.PushProvisioningActivity"
+private const val PROVIDER_INTERFACE = "com.stripe.android.pushProvisioning.PushProvisioningEphemeralKeyProvider"
 
 object PushProvisioningProxy {
-  private const val TAG = "StripePushProvisioning"
   private var description = "Added by Stripe"
   private var tokenRequiringTokenization: ReadableMap? = null
 
   fun getApiVersion(): String =
-    try {
-      Class.forName("com.stripe.android.pushProvisioning.PushProvisioningActivity")
-      PushProvisioningActivity.API_VERSION
-    } catch (e: Exception) {
-      Log.e(TAG, "PushProvisioning dependency not found")
-      ""
-    }
+    loadClass(ACTIVITY_CLASS)?.let { clazz ->
+      runCatching { clazz.getField("API_VERSION").get(null) as? String }.getOrNull()
+    } ?: ""
 
   fun isNFCEnabled(context: ReactApplicationContext): Boolean =
     if (context.packageManager.hasSystemFeature(PackageManager.FEATURE_NFC)) {
@@ -43,23 +42,22 @@ object PushProvisioningProxy {
     ephemeralKey: String,
     token: ReadableMap?,
   ) {
-    try {
-      Class.forName("com.stripe.android.pushProvisioning.PushProvisioningActivityStarter")
-      description = cardDescription
-      tokenRequiringTokenization = token
-      createActivityEventListener(context, view)
-      context.currentActivity?.let {
-        DefaultPushProvisioningProxy()
-          .beginPushProvisioning(it, description, EphemeralKeyProvider(ephemeralKey))
-      }
-        ?: run {
-          view.dispatchEvent(
-            createError("Failed", "Activity doesn't exist yet. You can safely retry."),
-          )
-        }
-    } catch (e: Exception) {
-      Log.e(TAG, "There was a problem using Stripe Android PushProvisioning: " + e.message)
+    if (loadClass(STARTER_CLASS) == null || loadClass(ARGS_CLASS) == null) {
+      Log.e(TAG, "PushProvisioning dependency not found")
+      return
     }
+
+    description = cardDescription
+    tokenRequiringTokenization = token
+    createActivityEventListener(context, view)
+    context.currentActivity?.let {
+      DefaultPushProvisioningProxy().beginPushProvisioning(it, description, EphemeralKeyProvider(ephemeralKey))
+    }
+      ?: run {
+        view.dispatchEvent(
+          createError("Failed", "Activity doesn't exist yet. You can safely retry."),
+        )
+      }
   }
 
   fun isCardInWallet(
@@ -83,63 +81,118 @@ object PushProvisioningProxy {
           data: Intent?,
         ) {
           super.onActivityResult(activity, requestCode, resultCode, data)
-          if (requestCode == TapAndPayProxy.REQUEST_CODE_TOKENIZE) {
-            view.dispatchEvent(
-              if (resultCode == RESULT_OK) {
-                null
-              } else {
-                mapError("Failed", "Failed to verify identity.", null, null, null, null)
-              },
-            )
-          } else if (requestCode == PushProvisioningActivityStarter.REQUEST_CODE) {
-            if (resultCode == PushProvisioningActivity.RESULT_OK) {
-              tokenRequiringTokenization?.let { tokenRequiringTokenization ->
-                val tokenReferenceId = tokenRequiringTokenization.getString("id")
-                if (tokenReferenceId.isNullOrBlank()) {
-                  view.dispatchEvent(
-                    mapError(
-                      "Failed",
-                      "Token object passed to `<AddToWalletButton />` is missing the `id` field.",
-                      null,
-                      null,
-                      null,
-                      null,
-                    ),
-                  )
+          when (requestCode) {
+            TapAndPayProxy.REQUEST_CODE_TOKENIZE ->
+              view.dispatchEvent(
+                if (resultCode == Activity.RESULT_OK) {
+                  null
                 } else {
-                  TapAndPayProxy.tokenize(
-                    activity,
-                    tokenReferenceId,
-                    tokenRequiringTokenization,
-                    description,
-                  )
-                }
-              } ?: run { view.dispatchEvent(null) }
-            } else if (resultCode == PushProvisioningActivity.RESULT_ERROR) {
-              data?.let {
-                val error: PushProvisioningActivityStarter.Error =
-                  PushProvisioningActivityStarter.Error.fromIntent(data)
-                view.dispatchEvent(
-                  mapError(error.code.toString(), error.message, null, null, null, null),
-                )
-              }
-            }
+                  mapError("Failed", "Failed to verify identity.", null, null, null, null)
+                },
+              )
+
+            getStaticInt(STARTER_CLASS, "REQUEST_CODE") ->
+              handlePushProvisioningResult(activity, view, resultCode, data)
           }
         }
       }
     context.addActivityEventListener(listener)
   }
+
+  private fun handlePushProvisioningResult(
+    activity: Activity,
+    view: AddToWalletButtonView,
+    resultCode: Int,
+    data: Intent?,
+  ) {
+    when (resultCode) {
+      getStaticInt(ACTIVITY_CLASS, "RESULT_OK") ->
+        tokenRequiringTokenization?.let { token ->
+          val tokenReferenceId = token.getString("id")
+          if (tokenReferenceId.isNullOrBlank()) {
+            view.dispatchEvent(
+              mapError(
+                "Failed",
+                "Token object passed to `<AddToWalletButton />` is missing the `id` field.",
+                null,
+                null,
+                null,
+                null,
+              ),
+            )
+          } else {
+            TapAndPayProxy.tokenize(activity, tokenReferenceId, token, description)
+          }
+        } ?: run { view.dispatchEvent(null) }
+
+      getStaticInt(ACTIVITY_CLASS, "RESULT_ERROR") ->
+        data?.let {
+          val (code, message) = parsePushProvisioningError(it) ?: ("Failed" to "Failed to add card to wallet.")
+          view.dispatchEvent(mapError(code ?: "Failed", message, null, null, null, null))
+        }
+    }
+  }
 }
 
-class DefaultPushProvisioningProxy {
+internal class DefaultPushProvisioningProxy {
   fun beginPushProvisioning(
     activity: Activity,
     description: String,
     provider: EphemeralKeyProvider,
   ) {
-    PushProvisioningActivityStarter(
-      activity,
-      PushProvisioningActivityStarter.Args(description, provider, false),
-    ).startForResult()
+    val starterClass = loadClass(STARTER_CLASS)
+    val argsClass = loadClass(ARGS_CLASS)
+    val providerInterface = loadClass(PROVIDER_INTERFACE)
+
+    if (starterClass == null || argsClass == null || providerInterface == null) {
+      Log.e(TAG, "PushProvisioning dependency not found")
+      return
+    }
+
+    try {
+      val args = argsClass
+        .getConstructor(String::class.java, providerInterface, Boolean::class.javaPrimitiveType)
+        .newInstance(description, provider, false)
+      val starter = starterClass
+        .getConstructor(Activity::class.java, argsClass)
+        .newInstance(activity, args)
+      starterClass.getMethod("startForResult").invoke(starter)
+    } catch (e: Exception) {
+      Log.e(TAG, "There was a problem using Stripe Android PushProvisioning: " + e.message)
+    }
+  }
+}
+
+private fun loadClass(name: String): Class<*>? =
+  try {
+    Class.forName(name)
+  } catch (_: Exception) {
+    null
+  }
+
+private fun getStaticInt(
+  className: String,
+  fieldName: String,
+): Int? {
+  val clazz = loadClass(className) ?: return null
+  return try {
+    clazz.getField(fieldName).getInt(null)
+  } catch (e: Exception) {
+    Log.e(TAG, "Unable to resolve $fieldName on $className: " + e.message)
+    null
+  }
+}
+
+private fun parsePushProvisioningError(data: Intent): Pair<String?, String?>? {
+  val errorClass = loadClass(ERROR_CLASS) ?: return null
+  return try {
+    val fromIntent = errorClass.getMethod("fromIntent", Intent::class.java)
+    val errorInstance = fromIntent.invoke(null, data)
+    val code = runCatching { errorClass.getMethod("getCode").invoke(errorInstance)?.toString() }.getOrNull()
+    val message = runCatching { errorClass.getMethod("getMessage").invoke(errorInstance)?.toString() }.getOrNull()
+    code to message
+  } catch (e: Exception) {
+    Log.e(TAG, "Unable to parse push provisioning error: " + e.message)
+    null
   }
 }
